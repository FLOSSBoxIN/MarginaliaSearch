<html>
 <head></head>
 <body>
  % CST8207 Assignment 13 - CentOS: Partitions, File Systems, single user % Ian! D. Allen – <idallen@idallen.ca>
    – [www.idallen.com] % Winter 2014 - January to April 2014 - Updated Thu Apr 17 00:32:06 EDT 2014 Due Date and Deliverables ========================= &gt; **Do not print this assignment on paper!** &gt; &gt; - On paper, you will miss updates, corrections, and hints added to the &gt; online version. &gt; - On paper, you cannot follow any of the [hyperlink URLs] that lead you &gt; to hints and course notes relevant to answering a question. &gt; - On paper, scrolling text boxes will be cut off and not print properly. - **Due Date**: `23h59 (11:59pm) Thursday April 17, 2014 (end of Week 14)` - Late assignments or wrong file names may not be marked. Please be accurate and punctual. - College policy does not allow assignments to be due after classes end. - **Available online** - Version 1 – 04:10 April 7, 2014 - **Prerequisites** - All [Class Notes][hyperlink URLs] since the beginning of term. - All your previous [Assignments]. - Completed [CentOS Virtual Machine] virtual machine installation (done in a previous assignment). - Completed [Assignment #08] (CentOS install and configure) - Completed [Assignment #12] (Sysadmin account) - An ability to **READ ALL THE WORDS** to work effectively. - **Deliverables** 1. Modifications to your [CentOS Virtual Machine] as given in this assignment. - **Do not delete any assignment work from your [CentOS Virtual Machine] until after the term is over!** 2. One text file uploaded to Blackboard according to the steps in the [Checking Program] section below. 3. Directory structure and files created and left for marking on the [Course Linux Server] (**CLS**).\ **Do not delete any assignment work from the CLS until after the term is over!** Purpose of this Assignment ========================== &gt; **Do not print this assignment on paper!** On paper, you cannot follow any &gt; of the hyperlink URLs that lead you to hints and course notes relevant to &gt; answering a question. This assignment is based on your weekly [Class Notes]. 1. Review the [Partitions and File Systems] commands in the [Class Notes]. 2. Practice creating and deleting partitions. Create file systems. Mount and unmount file systems. 3. Review [Booting and GRUB] in the [Class Notes]. 4. Boot into **single user** mode. (This is how you change a forgotten `root` password.) Introduction and Overview ========================= This is an overview of how you are expected to complete this assignment. Read all the words before you start working. &gt; Do not print this assignment on paper. On paper, you cannot follow any of &gt; the hyperlink URLs that lead you to hints and course notes relevant to &gt; answering a question. You also don’t get any of the later updates to the &gt; assignment. Do not print this assignment on paper. 1. Complete the readings in your weekly [Class Notes]. 2. Complete the **Tasks** listed below, in order. 3. Verify your own work before running the **Checking Program**. 4. Run the **Checking Program** to help you find errors. 5. Submit the output of the **Checking Program** to Blackboard before the due date. 6. **READ ALL THE WORDS** to work effectively and not waste time. You will create filesystem structure in your CLS home directory containing various directories and files. You will also make changes in your own Linux Virtual Machine running CentOS 6.5. You can use the **Checking Program** to check your work as you do the tasks. You can check your work with the checking program as often as you like before you submit your final mark. **Some task sections below require you to finish the whole section before running the checking program; you may not always be able to run the checking program successfully after every single task step.** When you are finished the tasks, leave the files and directories in place on both the CLS and your own Linux Virtual Machine as part of your deliverables. **Do not delete any assignment work until after the term is over!** Assignments may be re-marked at any time on the CLS; you must have your term work available on the CLS right until term end. &gt; Since I also do manual marking of student assignments, your final mark may &gt; not be the same as the mark submitted using the current version of the &gt; [Checking Program]. I do not guarantee that any version of the [Checking &gt; Program] will find all the errors in your work. Complete your assignments &gt; according to the specifications, not according to the incomplete set of &gt; mistakes detected by the [Checking Program]. Searching the course notes -------------------------- The current term’s course notes are always available on the Internet here: [CST8207 GNU/Linux Operating Systems I]. All the current and previous terms notes files are also stored on the CLS. You can learn about how to read and search these files using the command line on the CLS under the heading *Copies of the CST8207 course notes* near the bottom of the page [Course Linux Server]. The CLS Source Directory ------------------------ All references to the “Source Directory” below are to the CLS directory `~idallen/cst8207/14w/assignment13/` and that name starts with a *tilde* character `~` followed by a userid with no intervening slash. The leading tilde indicates to the shell that the pathname starts with the HOME directory of the account `idallen` (seven letters). You do not have permission to list the names of all the files in the Source Directory, but you can access any files whose names you already know. Commands, topics, and features covered -------------------------------------- Review course notes on [Partitions and File Systems] and [Booting and GRUB]. Use the on-line help (`man` command) for the commands listed below for more information. - `df` – show mounted partitions and amount of used/free space (optionally inodes available) on all mounted file systems - `du` – recursively display disk usage in directories - `fdisk` – to display, create, delete, and manage partitions; option `-l`is very useful See [Partitioning with fdisk] - `file` – determine what kind of thing a pathname is. Can show disk and partition file system types using option `-s` and will follow (dereference) symbolic links using option `-L` (upper case) - `mkfs` – create a file system on a device, usually a hard disk partition. - `mkswap` – initialize a partition for use as a Linux swap partition. - `mount` – mount a file system into the main file system tree or display a list of all mounted file systems, including devices, types, and mount points - `swapon` – tell the Linux kernel to use an initialized swap partition. - `umount` – detach (unmount) a mounted file system (e.g.&nbsp;that was mounted with `mount`). - `uname` – display system information, including kernel release (version) number - `runlevel` – display previous and current system Run Level Correct user, command lines, and command output ----------------------------------------------- - Most of the commands in this assignment require `root` privilege. You must use the `su` command to start a shell with the permissions of another user. The `root` user can use `su` to become any other user without requiring a password. - If you start a `root` subshell, your prompt will tell you if you are the `root` user by changing to include a `#` character instead of a `$` character. You can also use the commands `id` or `whoami` to show your current userid. - Some answers require you to record **command lines**. Do **not** include the shell **prompt** with your command lines. Give only the part of the command line that you would type yourself. - Make sure you know the difference between a command **line** (which is what you type into the shell) and command **output** (which is what the command displays on your screen). Pay attention to whether the question asks you to record the command line or the command output. Backup and Recovery on CentOS ----------------------------- 1. Take a snapshot of your virtual machine before you begin each section of this lab so that you can recover back to the snapshot if needed. - You can delete the unused snapshots if everything works well. - CentOS snapshots are very small and fast compared to your Windows snapshots; you can save lots of them. 2. *Are you keeping an external backup copy of all your coursework (including your virtual machines) somewhere? You should be!* Use a remote login, not the VMware console ------------------------------------------ I recommend that once you have booted your CentOS VM, you connect to it and work using a remote login session (e.g. `ssh` or `PuTTY`) where copy-and-paste works and where you can have multiple simultaneous connections into the VM. The VMware console is not friendly. If you can’t get an SSH (PuTTY or `ssh`) connection working into your Linux VM, see the [Network Diagnostics] page. Note that SSH sessions (and whatever you are doing inside them) do not survive across a VMware suspend. Make sure you save your editor files and exit your SSH session before you pause or suspend your virtual machine. (Editor sessions that run inside the VMware console do survive across suspend and resume, since they don’t depend on a network connection.) &gt; Advanced users may look into the various virtual terminal programs such as &gt; `tmux` and `screen` that do allow you to suspend and resume your sessions &gt; even from a remote login. The Answer File `answer.txt` ---------------------------- Where you are required to record or save a command line or its output into [The Answer File], **do** the command and then copy and **record** the command line or its output as a separate line into an `answer.txt` file in your CentOS `assignment13` directory. You will be told how many lines to save in the file. If you can’t answer a question, leave a blank line in this answer file. (The `vim` option `:set number` may be useful to you as you edit.) You can use either `nl` or `cat -n` to show the contents of a file with line numbers, to make sure each answer is on its correct line number. Tasks ===== - Do the following tasks in order, from top to bottom. - Pay attention as to which tasks must be done in your own [CentOS Virtual Machine] and which must be done in your account on the [Course Linux Server]. - Tasks done on your own [CentOS Virtual Machine] require you to run a marking program in that Virtual machine. That marking program will transfer marking data from the VM to the CLS for marking. - Your instructor will mark on the due date the work transferred to your account on the CLS. Leave all your work on the CLS and do not modify it. - **Do not delete any assignment work from the CLS until after the course is over.** - **READ ALL THE WORDS!** and do not skip steps. Set Up – The Base Directory on the CLS -------------------------------------- 1. Do a [Remote Login] to the [Course Linux Server] (**CLS**) from any existing computer, using the host name appropriate for whether you are on-campus or off-campus. 2. Create the CLS directory `~/CST8207-14W/Assignments/assignment13` 3. Create the `check` symbolic link needed to run the **Checking Program**, as described in the section [Part II - Check and Submit] below. Run [Part II - Check and Submit] to verify your work so far. CentOS: Snapshot ---------------- 0. Complete your [CentOS Virtual Machine] Installation and Verification. - Make sure it passes the checks for disk sizes and package counts. - Complete these critical system administration tasks required in [Assignment #08] and [Assignment #12]: a. Create your own personal sysadmin account. b. Install and configure the NTP package. 1. Before you begin this assignment, create a snapshot of your [CentOS Virtual Machine]. - Enter a comment explaining where and when you took this snapshot. - You can restore back to this snapshot if anything goes wrong. CentOS: Set Up – The Base Directory on CentOS --------------------------------------------- 1. In your own account in your [CentOS Virtual Machine], also make the directory `~/CST8207-14W/Assignments/assignment13` (the same hierarchy as you have already made on the CLS). **This CentOS `assignmment13` directory is the *base* directory for all pathnames in this assignment. Store your CentOS files and answers below in this *base* `assignment13` directory.** Run the **Fetch** and [Checking Program] to verify your work so far. CentOS: Add a second disk to your VM: `sdb` ------------------------------------------- &gt; You will add a second hard disk to your [CentOS Virtual Machine], and &gt; partition it. The procedure for adding a hard disk to an actual physical &gt; computer is different only in the steps that take place while the machine &gt; is powered off. Any step carried out while the machine is running would be &gt; the same for physical machines as it is for virtual machines. The console &gt; of a physical machine is its actual keyboard and monitor, but in the case &gt; of a VM, the console is the VMware window of the machine. Most of the system admin commands in this assignment access the raw disk and will require you to use `su` to gain `root` permissions (unless you are in single-user mode and therefore running everything as `root`). **If you get “permission denied” errors, you forgot to use `su`.** 1. If your [CentOS Virtual Machine] is not already powered off, login and use the correct command to power off the virtual machine. - Never user the VMware **Power Off** button to kill power! - Never unplug a running Linux machine! 2. With your CentOS machine still powered off, use the **VMware** **Settings** menu for your CentOS VM to add to your VM a virtual `1GB` hard disk, accepting defaults for everything except the size. See [Create VMware Disk]. Create the disk exactly `1GB` in size. 3. After adding the new disk, power on your VM, then login as your system administrator user. 4. Ensure the `/proc/partitions` file contains the second disk you added. - Verify that there is a second disk of the correct size: - The size of your second drive should be `1048576`. - Divide: `1048576/1024/1024` to confirm the number of gigabytes. - Verify that no partitions are listed for the second disk. - If you have any `sdb1` or `sdb2` or other `sdb` partitions, this is *not* a new disk with no partition table. Get help. - Note the three-letter device name of the second disk. 5. When the second disk is correct, copy `/proc/partitions` to file `partitions_before.txt` in your CentOS base directory (6 lines, 20 words). Remember: all files should be placed under your sysadmin base directory on CentOS. 6. Verify that the three-letter device name for the second disk also exists under the `/dev` directory. Put a long (`ls -l`) listing of all names under `/dev` that start with the first two letters of the new disk name into file `sd_all.txt` in your base directory. - Do not change your current directory. - Use the absolute pathnames for the devices. - No pipeline or other command is needed. - The output should show the absolute paths of two disks, and two partitions in the first disk. - [**Hint**] The useful `file` command – what is that thing? ----------------------------------------------- The Unix/Linux `file` command is very useful for identifying things in the file system, such as directories, programs, images, files, and special files that might contain file systems, such as disk partitions: 1. Run `file -s` on (the device name of) each of your two disks. Note that your new empty disk says simply `data` while your ROOT disk has a very long line full of information about the boot sector and partitions: # file -s /dev/sd[ab] /dev/sda: x86 boot sector; GRand Unified Bootloader, ... /dev/sdb: data Save the two lines of `file` output in a `file_s.txt` file (2 lines, 44 words) in your CentOS base directory. Viewing and Creating Partitions: `fdisk` ---------------------------------------- 1. First, you must have added a new `1GB` hard drive in **VMware** and rebooted, as described above. Log in to the machine. Let’s look at the partitions on the first disk (`sda`): 2. Run (always with `root` privileges) `fdisk -cul /dev/sda` and you will see the two partitions on your first (`sda`) disk that holds your main ROOT file system: # fdisk -cul /dev/sda Disk /dev/sda: 2147 MB, 2147483648 bytes 255 heads, 63 sectors/track, 261 cylinders, total 4194304 sectors Units = sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disk identifier: 0x00000000 Device Boot Start End Blocks Id System /dev/sda1 * 2048 3074047 1536000 83 Linux /dev/sda2 3074048 4194303 560128 82 Linux swap / Solaris **DO NOT OVERWRITE `/dev/sda` THAT IS YOUR MAIN CENTOS INSTALLATION DRIVE!** Now let’s look at the second disk (`sdb`) that should have **no** partitions: 3. Run (always with `root` privileges) `fdisk -cul /dev/sdb` and make sure you see `Disk /dev/sdb: 1073 MB` with no errors and no partitions listed under it. # fdisk -cul /dev/sdb Disk /dev/sdb: 1073 MB, 1073741824 bytes If you don’t see `1073 MB`, then shut down, delete the disk, recreate the disk, and reboot until your **1GB** disk install works. &gt; Make sure you **only** change things on this new `sdb` disk in this &gt; section! The `sda` disk is your Linux **ROOT** disk; if you damage it you &gt; will need to recover back to your snapshot. *Make sure you have a snapshot &gt; to go back to!* 4. In the `man` page for the `fdisk` command, locate and make a note of two option letters: - The option to “*Switch off DOS-compatible mode. (Recommended)*” - The option to “*give sizes in sectors instead of cylinders*” We are now going to run the `fdisk` program in **interactive** mode. &gt; To learn more on how to use `fdisk`, see your in-class notes or see &gt; 
   <http: tldp.org howto partition fdisk_partitioning.html>
     5. Start `fdisk` interactively as `root` using the command `fdisk`*devicename*, where *devicename* is the absolute path of the device corresponding to the new disk under `/dev`. - As `fdisk` starts, read the upper-case `WARNING` about **DOS-compatible mode**. This is a serious (**strongly recommended**) warning! - Type the correct one-letter command to quit the `fdisk` program. Do not continue. 6. Re-run same `fdisk` command, this time inserting the two option letters you found in the `man` page, above. (Keep the same device name.) - The DOS `WARNING` should be gone when you start `fdisk` with those two options. (One other harmless warning about an invalid flag will remain. This is normal, since the new virtual disk is empty and has not been initialized yet. Ignore the one warning.) - Always use these two `fdisk` options on CentOS. (Other versions of `fdisk` use these options as defaults.) &gt; You should avoid this DOS warning message in future by always using the &gt; `-cu` command line options to `fdisk` (RTFM) when you run it, even &gt; non-interactively. You might even consider making a shell alias that always &gt; supplies these two options to `fdisk` every time you use it: &gt; `alias fdisk='fdisk -cu'` 7. The `fdisk` utility should now be running in **interactive** mode, prompting you for input with a different **prompt** from your BASH shell **prompt**: `Command (m for help):` - This prompt is the `fdisk` utility **prompt**. - Do not type Linux commands into the `fdisk` program prompt! - As it says, type the command letter `m` for a list of helpful `fdisk` interactive command letters. 8. Inside interactive `fdisk` use the command to display the partition table and verify that the disk you are working on is the `1GB` disk (1073MB) with no partition table and no partitions. 9. Read the list of `Command action` commands. Copy the lines below into a file `fdisk_info.txt` and replace each underscore character with the (one-character) `fdisk` command letter that does the listed function: 1. _ save/write partition table to disk (and exit) 2. _ change a partition's type (system id) 3. _ exit/quit fdisk without saving changes 4. _ display/list/print the table of all partitions 5. _ create/add a new partition 6. _ show/display/list partition types (system ids) 7. _ remove/delete a partition You will need to use every one of these command letters in this assignment. Make sure you get them right. 10. Use the `fdisk` command letter that lists all the two-hex-digit *partition types*. (Partition types are also called “system identifiers”.) Use that list to answer this: Add the lines below to the end of the same `fdisk_info.txt` file and replace the underscore on each line with the hex type number (system id) of the following partition types, making sure you read the numbers correctly from the screen: 8. _ Linux 9. _ Linux swap / So 10. _ HPFS/NTFS 11. _ W95 FAT32 (LBA) The swap line, above, is short for `Linux swap / Solaris`. You will need all these partition ID numbers later in the assignment. Your completed `fdisk_info.txt` file should be 11 lines 67 words. Run the **Fetch** and [Checking Program] to verify your work so far. ### Creating Partitions using `fdisk` &gt; To learn more on how to use `fdisk`, see your in-class notes or see &gt; 
    <http: tldp.org howto partition fdisk_partitioning.html>
      Below, we will use the correct commands in the `fdisk` utility to create the following **seven** new partitions on your `sdb` disk. - Always accept the **default** proposed by `fdisk` for the **starting** sector of a new partition. Push **[Enter]**; do not type any numbers. You only need to set the **end** sector (size) of the new partition using the `+size{K,M,G}` syntax shown by `fdisk`. - `fdisk` will sometimes adjust the size of each partition slightly to fit the DOS partition table disk geometry and sector size. Don’t be alarmed that the size that `fdisk` creates and displays to you isn’t *exactly* the size you asked for. - Use the `fdisk` command letter to display the partition table **after each change** to confirm that you created the correct partition with the correct size. - No changes will be saved to disk unless you explicitly use the `fdisk` command letter to save them. You can always quit `fdisk` before saving any changes. - First, make sure the disk you are about to change has *no* partitions configured. If you see partitions, you are using `fdisk` on *the wrong disk*. Make sure you use `fdisk` on the new disk device name! 1. On the empty disk (the new disk), create a **primary** first partition of size **200M**. - **Use the suffix letter `M`, not `MB`, inside `fdisk`.** Using `MB` as a suffix creates partitions using power-of-ten MegaBytes (1,000,000) instead of power-of-two [MebiBytes]. - The type (system id) will default to type **Linux**. Don’t change the type. - Use the `fdisk` command letter to display the partition table to confirm the values and make sure that the size (in blocks) looks correct for the size you requested. - The `Start` sector of this first partition should be `2048`. If it isn’t, you probably forgot to use the option that turns off DOS compatibility. Quit and restart with the correct two options. - The `End` sector must be `411647`. If it is less, re-read all the words in this question, especially the words in the sentence starting with “Use the suffix…”. 2. Create a **primary** second partition of **100M**. - Leave the type (**Linux**) as default. - Confirm the change. The `Number of blocks` must be `102400`. (If it is less, re-read all the words in the previous question.) 3. Create an **extended** third partition large enough to host the following three **logical** partitions inside it. - You must make the extended partition large enough to hold **all three** logical partitions described in the next step: &gt; NOTE: As mentioned in class, you cannot create an extended partition &gt; *exactly* the sum of the sizes of the logical partitions inside it. You &gt; need to make the extended a bit *larger* to accommodate the overhead of the &gt; logical partition information. Experiment to see how much “a bit larger” &gt; means. The end of the extended partition must be *less than* sector 2097151 &gt; that is the last sector in the disk. (i.e.&nbsp;Don’t use up the whole disk for &gt; the extended partition!) 4. Create these three **logical** partitions inside the **extended** partition that you created in the previous step: 1. The size of the **first logical** partition is **200M**. Leave the partition type set as “**Linux**”. 2. The size of the **second logical** partition is **100M**. Change the partition type to “**Linux swap**”. 3. The size of the **third logical** partition is **300M**. Change the partition type to “**HPFS/NTFS**”. If you run out of space creating the logical partitions inside the extended partition, you can delete the extended partition and start over as many times as needed. (You can also start over by exiting `fdisk` without saving/writing any of your partition changes.) Make the extended partition *just big enough* to contain the logical partitions, no bigger. Try not to have much wasted space between the end of the third logical partition (its **end** sector) and the end of the extended partition (its **end** sector). **Hint:** `610M` is too big; make it smaller. 5. Create a **primary** fourth partition that uses up the rest of the space after the end of the extended partition. - To do this, accept the defaults for both the start and the end of the partition. - The last **end** sector of this last partition will be the end sector of the disk: `2097151` - The partition should be about 121MB in size. - Set the partition type to `W95 FAT32 (LBA)`. 6. Did you remember to set the correct partition **types** (system id) on each of the seven partitions? 7. When all seven partitions are created, with the correct types and sizes, **save** your changes (seven partitions) to disk, which will cause `fdisk` to exit. You will return to your shell prompt. ### Verify the partitions 1. Verify the creation of seven new `sdb` partitions using `ls -l /dev/sd*` and by looking at the new contents of the system `partitions` file, as you did before. You should have exactly **seven** partitions on this second disk. 2. Again, copy the system `partitions` file into a `partitions_after.txt` file. (13 lines, 48 words. You might look and see how it differs from the previous values you copied in `partitions_before.txt`. You should see seven new partitions on the new disk.) 3. From the command line, use `fdisk` (non-interactive) to show the partition table for the new disk, always using the above-mentioned two options to give sector (not cylinder) output and avoid the DOS compatibility warnings. Part of the output will look similar to this: Device Boot Start End Blocks Id System /dev/sdb1 2048 411647 204800 83 Linux /dev/sdb2 411648 616447 102400 83 Linux /dev/sdb3 616448 1853439 618496 5 Extended /dev/sdb4 1853440 2097151 121856 c W95 FAT32 (LBA) /dev/sdb5 618496 1028095 204800 83 Linux /dev/sdb6 1030144 1234943 102400 82 Linux swap / Solaris /dev/sdb7 1236992 1851391 307200 7 HPFS/NTFS The exact numbers for **end** and **blocks** of `sdb3` and the **start** and **blocks** of `sdb4` may differ slightly from the numbers above. All the other numbers should match *exactly*. Save the output for your disk into an `fdisk_sdb.txt` file (16 lines, 98 words). 4. Look at your new disk (only the new disk) and record these three answers (just the answers) on lines in [The Answer File]: **Line 1:** Full absolute device names of all primary (not extended) partitions on the new disk.\ **Line 2:** Full absolute device names of all extended partitions.\ **Line 3:** Full absolute device names of all logical partitions. **Hint:** Re-read the word **absolute** in the above sentences. ### Deleting a logical partition using `fdisk` 1. You have **seven** partitions on your second hard disk. (Make sure this is true before continuing!) Your partition table should look quite similar to the table shown in the previous section. (Read the comments at the bottom of the table to know the allowed differences.) - Create a **VMware** backup **snapshot** of this virtual machine, so you can return here if things go wrong. 2. Start `fdisk` interactively. (Remember the two options to avoid DOS warnings!) a) Show the partition table. You should have **seven** partitions. b) Delete the first primary partition that has size **100M**. - Display the new partition table. You should still have two type `Linux` (**System ID 83**) partitions left. - Note how when you delete a primary partition, none of the other partitions change names. - You now have **six** remaining partitions on `sdb`. c) Quit `fdisk` without saving any changes. - Do not save the changes. You still have seven partitions. d) Start `fdisk` interactively again. (Remember the two options to avoid warnings!) e) Show the partition table. You should still have **seven** partitions. - You have **seven** because you did not save any changes, right? f) Delete the first **logical** (not primary) partition that has size **200M**. - Display the new partition table. You now have six partitions. - Note how when you delete a logical partition `sdb5` the other logical partitions above it all renumber themselves downward to keep the first logical partition numbered `sdb5`. Logical partitions always number consecutively from `5`. - You now have **six** remaining partitions on `sdb`. g) Now **save** (write) the new partition table (six partitions) to disk, which will cause `fdisk` to exit. You will return to your shell prompt. 3. Record the full absolute device names of all remaining logical partitions on **Line 4** in [The Answer File] (two names only). Run the **Fetch** and [Checking Program] to verify your work so far. ### Snapshot and Practice 1. Take a VMware back-up snapshot now and name it something like `done_fdisk`. 2. For practice, use `fdisk` interactively to delete all the partitions and then re-create them again, **without** writing out your changes. - Recreate the above six partitions, but don’t save your work. - Would you remember how to do this when asked to demonstrate it at a **job interview**? When installing a new disk? Practice! Creating file systems using `mkfs` ---------------------------------- &gt; After partitioning a disk, the next step is making file systems inside the &gt; partitions. You must have six partitions available to continue with this &gt; section. To continue with the next sections of this lab, you must have successfully created these **six** (remaining) partitions on the 1GB disk. Verify that they have exactly the same **Device** numbers, exactly the same `Id` and `System`, *approximately* the same `Start` and `End`, and *approximately* the same number of `Blocks`. Device Boot Start End Blocks Id System /dev/sdb1 2048 411647 204800 83 Linux /dev/sdb2 411648 616447 102400 83 Linux /dev/sdb3 616448 1853439 618496 5 Extended /dev/sdb4 1853440 2097151 121856 c W95 FAT32 (LBA) /dev/sdb5 1030144 1234943 102400 82 Linux swap / Solaris /dev/sdb6 1236992 1851391 307200 7 HPFS/NTFS **Do not proceed until you have the above six partitions created**.\ The sizes may vary *slightly*. The System ID must match. The **end** of the `Extended` partition must be **less than** the end sector of the disk. There is a large gap between the start of the extended partition and the start of the first logical partition; this gap corresponds to the space left by the deleted **200M** logical partition. All file system commands in the next part of this lab that refer to a hard disk will **use one of the above partitions**. Do not continue until you have the above partitions created correctly. 1. Enter the number of sectors in the gap at the start of the extended partition as **Line 5** in [The Answer File]. - *Read All The Words* in the previous paragraphs to know what “the gap” means. 2. Find the device names of the two partitions that have partition type of `Linux` (**System ID 83**). (These should be exactly two of the six partitions.) A) On the *first* Linux partition: a) Run `file -s` on this empty partition and note the uninteresting output when the partition has no file system in it. b) Use a command to create a Linux type `ext3` file system on this partition. - Many lines will print on your screen, telling you the characteristics of the file system you just created. Make sure there are no error messages! - Record the exact command line you used to create the file system as **Line 6** in [The Answer File]. c) Run `file -s` on this same partition name again to show the type of file system in the partition. - You should see one single output line containing this partition type text: `ext3 filesystem data` - Repeat the command and record the one line of **partition type output** as **Line 7** in [The Answer File]. B) On the *second* Linux partition: a) Repeat the above two commands for creating a file system and showing its type, but use a file system type of `ext4` this time. - Record your command line and the partition type output line on **Lines 8 and 9** in [The Answer File]. 3. On the only `W95 FAT` partition: a) Repeat the above command for creating a file system, but use a file system type of `vfat` this time. - The command will fail with: `mkfs.vfat: No such file or directory` - The commands for creating DOS file systems are not installed! - Confirm the missing command by running: `whereis mkfs.vfat` - We can try to fix this by finding and installing the right package. b) To locate the missing package run a query command: `yum whatprovides '*/mkfs.vfat'` - `yum` will update some internal files then tell you that the missing package name is `dosfstools` (with a version number). c) Install the missing `dosfstools` package. - Verify that `which mkfs.vfat` now finds the command. - (If it doesn’t find it, make sure `/sbin` is in your `PATH`.) d) Again: Repeat the above two commands for creating a file system and showing its type, but use a file system type of `vfat` this time. - If you have installed the missing `dosfstools` package, everything will work correctly with no errors. - Record your command line and the partition type output line on **Lines 10 and 11** in [The Answer File]. 4. On the only `HPFS/NTFS` partition: a) Repeat the above steps for creating a file system, but use a file system type of `ntfs` this time. - The command will fail with: `mkfs.ntfs: No such file or directory` - The commands for creating NTFS file systems are not installed! - Confirm the missing command by running: `whereis mkfs.ntfs` - We can try to fix this by finding and installing the right package. b) As you did before, try to locate the missing package based on the missing `mkfs.ntfs` file name. - `yum` will update some internal files then tell you `No Matches found` - This version of CentOS does not support NTFS file systems using the standard `yum` repositories for software! `:-(` - We could install an experimental NTFS software package, but we don’t want any experimental software on our server machine. c) Give up without making any NTFS file system here. d) Send an angry note to Microsoft for using undocumented file system formats that have to be experimentally reverse-engineered. Run the **Fetch** and [Checking Program] to verify your work so far. ### Snapshot and Practice 1. Take a VMware back-up snapshot now and name it something like `done_mkfs`. 2. For practice, repeat this section again, re-typing each of the commands you used to create the file systems. Would you remember how to do this when asked to demonstrate it at a **job interview**? When installing a new disk? Practice! Mounting &amp; Unmounting a Linux File system using `mount` ------------------------------------------------------- &gt; After partitioning a disk and creating file systems, next comes mounting &gt; the new file systems onto existing directories in the system. You must have &gt; created six partitions with three new file systems to continue. 1. List all the currently mounted file systems using the `mount` command with no arguments. - You should see six lines, or seven if you use VMware and have a `vmware-vmblock` device mounted. - None of the above new file systems should be visible in the output. If you have any disk partitions mounted other than the ROOT partition (`sda1`), unmount the partitions now before continuing. - Save the `mount` output as a `mount_before.txt` file. (6 lines, 36 words or 7 lines, 42 words if you use VMware) 2. Use a single command to create (empty) directories named `/mnt/ext3`, `/mnt/ext4`, and `/mnt/vfat` to use as mount points for all the file systems you successfully created above. - If you don’t remember to create the empty directory first, the `mount` command will generate error messages such as `mount point /mnt/ext3 does not exist`. 3. Use `mount` commands to mount all three file systems you created previously, each mounted on its own self-named directory. (Recall that each file system was created with a particular type. Match the partition file system type with the directory name.) - You do not need to specify the type of the file system being mounted, because `mount` can tell. If `mount` says `you must specify the filesystem type` then almost surely there is *no* file system created in that partition. Fix it and then try again. - Record as **Lines 12-14** in [The Answer File] the three `mount` commands you used to mount these three partitions. (Remember: The directories must already exist!) &gt; Reminder: You almost never need the `-t` option when mounting a file &gt; system, since Linux knows the type by looking inside the partition. If &gt; `mount` ever gives the error `you must specify the filesystem type`, it is &gt; because there is **no** file system created inside that partition. The &gt; `file -s` command can confirm this for you. Create the file system &gt; first, then mount it. ### Show mounted: `mount` 1. Use `mount` without any arguments to verify that you have three new mounted file systems. Each file system type should match the directory name on which it is mounted. Each file system should be mounted only **once**. (If you have duplicate entries, unmount them using the `umount` command.) - Save the `mount` output as a `mount_after.txt` file. (9 lines, 54 words or 10 lines, 60 words if you use VMware) 2. Save the output (run as `root`) of `file -s /dev/sd*` as a `file_after.txt` file. (10 lines) 3. Save the output (run as `root`) of the command `blkid` as a `blkid_after.txt` file. (at least 5 lines) - This command shows you the `UUID` values that you could use to uniquely identify each partition in the first column of the `/etc/fstab` file. (Do not use `UUID` mount names in this assignment; use the device partition names when the time comes.) 4. Use the command `ls -lid / /mnt/ext?` to see the inode numbers of the three Linux directories mounted on your system. - Notes that all three directories have the *same* inode number `2`. Aren’t inode numbers supposed to be unique? (Review [Links and Inodes].) Know why these three directories have the same inode number. (This question may appear on your final exam.) 5. Take a VMware back-up Snapshot now and name it something like `done_3mount`. ### Show mounted: `df` 1. The `df` (“disk free”) command shows information about mounted file systems, including the amount of disk space used and disk space still available. A useful option is `-h` that shows output in “human-readable” form. - Use the command `df -h` to see the sizes of the file systems. 2. The two new, empty Linux file systems we just mounted show about `5.6MB` of space used. Why is a new file system not empty? (This question may appear on your final exam.) 3. If you add up the `Used` plus `Available` disk space on a `VFAT` (DOS) file system, it exactly equals the `Size` of the file system. If you add up `Used`+`Available` on a `Linux` file system, it is usually about 5% smaller than the `Size` of the file system. [Why?] (This question may appear on your final exam.) ### Disk Usage - `du` &gt; The `du` command walks the file system and recursively shows the disk usage &gt; in every directory under a directory. &gt; &gt; - With the `-s` option, only the `summary` of the disk usage is shown. &gt; - With the `-h` option, the output is given in “human-readable” form &gt; (similar to the same option to `df`). &gt; - With the `-x` option, `du` will stay within a file system and not &gt; follow directories that are mount points. 1. Use `du` to show a **summary** of the **human-readable** amount of disk space on only the `/` (ROOT) file system. - You will need three option letters. - The command will take some time to finish! Wait for it! 2. Compare the speed of running the above `du` command (which has to walk the entire ROOT directory tree) against the speed of running `df` in the previous section. This is why sysadmin prever `df`! 3. Unmount all three file systems that you just mounted. - Make sure that the system is back to the state you recorded in the `mount_before.txt` file. Only seven lines! Run the **Fetch** and [Checking Program] to verify your work so far. ### Practice 1. For practice, repeat this section again, re-typing each of the commands you used to mount and unmount each file system. Would you remember how to do this when asked to demonstrate it at a **job interview**? When installing a new disk? Practice! Preparing a Swap Partition using `mkswap` and `swapon` ------------------------------------------------------ 1. Use one command to initialize the `Linux swap` partition on your new **1GB** disk. a) Record the command line you used as **Line 15** in [The Answer File]. b) Record as **Line 16** in [The Answer File] the **output** of using `file -s` on the `Linux swap` partition. - The output should include the words `swap file` 2. Use one command to tell the kernel to use the new swap device. - Record the command line you used as **Line 17** in [The Answer File]. 3. Display the list of active swap partitions. - Save the output of this command in a `swap.txt` file. (3 lines, 15 words) 4. Disconnect the swap area you just connected. - Only one swap partition should remain, on your first disk. Run the **Fetch** and [Checking Program] to verify your work so far. ### Snapshot and Practice 1. Take a VMware back-up snapshot now and name it something like `done_swap`. 2. For practice, repeat this section again, re-typing each of the commands you used to initialize and enable the swap partition. Would you remember how to do this when asked to demonstrate it at a **job interview**? When installing a new disk? Practice! Kernel Version Number (release number) -------------------------------------- Your Linux kernel has a **version** number, as in “What **version** of the kernel are you running? I’m running **version** `2.6.32`”. Unfortunately, the command that prints system information, including the kernel **version** number, calls the number a kernel **release** number, because it uses the option name **version** to stand for the kernel **compile date**. When using this system information command you must use the option named **release** to display the kernel version number. 1. Display **only** the version (release) of the Linux kernel that is running on CentOS (19 characters): - Record the command line you must use as **Line 18** in [The Answer File]. - Record the one line of output for CentOS as **Line 19** in [The Answer File]. (The output starts with the digit `2` on CentOS.) - Log in to the CLS find out what kernel version it is running. Record the one line of output for the CLS as **Line 20** in [The Answer File]. (The output starts with the digit `3` on the CLS – the CLS runs a newer kernel than CentOS.) Run the **Fetch** and [Checking Program] to verify your work so far. Booting into single-user mode (changing forgotten `root` password) ------------------------------------------------------------------ &gt; If you find yourself locked out of a Linux machine, and you have access to &gt; the console, booting into single user mode will will often not require a &gt; password, and in single-user mode you are given a `root` shell and can &gt; change passwords or perform various other repair tasks. (Some systems &gt; **do** password-protect single-user mode, in which case you would need to &gt; boot a “live” or “rescue” CD to reset your `root` password.) Review [Booting and GRUB]. This section depends on a successful [CentOS Virtual Machine] installation, including a visible (not hidden) GRUB menu. (You made these changes when you configured CentOS in an earlier assignment.) To change a forgotten `root` password or do maintenance on the system that requires it to be quiescent (no users or disk activity), you can boot your system in a restricted **single-user** mode that does not start many system daemons and goes directly into a `root` shell prompt on the system console without requiring a password. The system should not be left in single-user mode; many service programs are not started. Networking may not be enabled; you may not even be able to log-in remotely in single-user mode. 1. View your CentOS GRUB configuration file and look at the (very long) `kernel` line in that file. Note all the options used on the right end of the `kernel` line; you will see them again soon. - Record on **Line 21** in [The Answer File] the Linux absolute pathname of this GRUB configuration file. 2. Record on **Line 22** in [The Answer File] the kernel option keyword used in booting a machine single-user (maintenance mode). (one word) 3. Safely reboot your CentOS VM into the GRUB menu and halt the time-out: - When the boot process begins, if you correctly disabled the `hiddenmenu` command in GRUB, you will boot directly to the GNU GRUB menu where you should see a one-line list of CentOS systems to boot and at the bottom a 30 second countdown in progress. - Interrupt the countdown by pressing an arrow key. (If you didn’t disable `hiddenmenu`, when the countdown is interrupted your system should display the one-entry GRUB menu.) ![CentOS 6 GRUB Menu] 4. Now, just as the GRUB menu instructions tell you, to modify the kernel arguments you press just the single letter `a` – just the letter key, no `[Enter]` key! - After pressing `a` you will see your cursor on a line that ends with the same `kernel` arguments you viewed earlier in the configuration file. - You can use the `[Home]` key to zoom to the left end of the kernel options line, and the `[End]` key to zoom to the right. ![CentOS 6 Kernel Options] 5. Modify this kernel options line so that the system will boot single-user. (Add the correct kernel option keyword to the right end of the line.) - As the instructions say, push **[Enter]** to accept your changes and directly boot the system using these new kernel options. - These changes to the kernel options are **not** saved back into the configuration file – they are only in effect for this boot menu. - (If you wanted to abandon your changes and leave the menu entry unmodified, you would have used the **Escape** key, as it says.) 6. The system should come up in single-user (maintenance) mode with a `root` shell prompt. (If you get a `login` prompt, you didn’t use the right kernel option keyword. Reboot into GRUB and try again.) - You can perform any `root` function at this prompt, including changing passwords (even the `root` password). - Often single-user mode has no networking enabled and only a minimal number of file systems mounted. 7. From the single-user shell, place a full list of all processes for all users, **BSD** format, text user name (not numeric UID), full wide listing (not truncated at all), into a `psbsd_single.txt` file. (All assignment answer files must be saved in your sysadmin base directory.) The output should be approximately 52 lines and 4KB. All the processes will be owned by `root`. The first two lines should look similar to this: USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND root 1 0.0 0.5 2900 1380 ? Ss 16:35 0:01 /sbin/init Remember to fix the owner and group of the file. 8. Use the command that displays the previous and current Run Level (two words on one line) and record this line of output as **Line 23** in [The Answer File]. 9. Leave single-user mode and let the system finish booting into full multi-user mode: - Leaving single-user mode does *not* mean rebooting the machine; do not reboot or shut down the machine. - Go directly from single-user to multi-user mode without a shutdown or reboot. - The `login` prompt should appear on the console. 10. Log in as your sysadmin account (optionally use an SSH login, not the terrible console window) and repeat the command that displays the previous and current Run Level and save the output as **Line 24** in [The Answer File] (two more words on one line). - If you rebooted the machine, you won’t have the right answer here. Boot back into single-user mode and then transition to multi-user mode without a shutdown or reboot. Run the **Fetch** and [Checking Program] to verify your work so far. When you are All Done --------------------- That is all the tasks you need to do. Check your work a final time using the **Fetch** and [Checking Program] and save the output on the CLS as described below. Submit your mark following the directions below. &gt; Optional: Keeping your main [CentOS Virtual Machine] snapshot, remove any &gt; intermediate snapshots you no longer require, to free up disk space. - Be &gt; careful not to remove your current work! Checking, Marking, and Submitting your Work =========================================== **Summary:** Do some tasks, then run the **Fetch** and checking program to verify your work as you go. You can run the **Fetch** and checking program as often as you want. When you have the best mark, upload the marks file to Blackboard. &gt; Since I also do manual marking of student assignments, your final mark may &gt; not be the same as the mark submitted using the current version of the &gt; [Checking Program]. I do not guarantee that any version of the [Checking &gt; Program] will find all the errors in your work. Complete your assignments &gt; according to the specifications, not according to the incomplete set of the &gt; mistakes detected by the [Checking Program]. The checking program resides on the [Course Linux Server], but your work is on your [CentOS Virtual Machine]. There is a **Fetch** program that you must download and use on your CentOS Virtual Machine to copy information from your CentOS Virtual Machine to your account on the CLS so that the checking program can check it on the CLS. Once the **Fetch** program has fetched these files from your Virtual Machine to the CLS, you can run the checking program on the CLS to check what is saved in the files. When you make changes on your CentOS Virtual Machine, you need to run the **Fetch** program again on CentOS to update the saved files on the CLS. Simply running the checking program on the CLS will *not* update the saved files on the CLS. You must run the **Fetch** program on your CentOS VM when you make changes on your [CentOS Virtual Machine]. Part I - Fetch and Check ------------------------ Do all the following steps on your [CentOS Virtual Machine]. Read through the whole list before you start typing anything. An example of what to type is given below the descriptions that follow. Failure to **read all the words** will lock your account out of the CLS. 1. Log in to CentOS. Use your sysadmin non-`root` account (same userid as Blackboard). 2. Create a directory in your sysadmin account named `CST8207-14W/Assignments/assignment13` (use the same directory hierarchy as you already have in your own account on the CLS). This is your **base** directory for this assignment. 3. Change to the above sysadmin base directory (on CentOS!). 4. As shown below, use `curl` to get a copy of the **Fetch** program from the given URL into a file named `do.sh`. Make sure you have a file named `do.sh` in your sysadmin base directory. You only need to download this *once* per assignment. 5. **Warning:** If you printed this page on paper, you may not be able to scroll right to read the whole web URL that you must pass to the `curl` program. $ whoami ; hostname ; pwd abcd0001 # your userid, not abcd0001 abcd0001 # your userid, not abcd0001 /home/abcd0001/CST8207-14W/Assignments/assignment13 $ url=http://teaching.idallen.com/cst8207/14w/notes/data/assignment13do.sh $ curl -A mozilla "$url" &gt;do.sh [... make sure you scroll right to read the full web URL above ...] [... various download statistics print here ...] $ fgrep -i 'error' do.sh # make sure no errors (no output) $ head -n1 do.sh # make sure it's a shell script #!/bin/sh -u 5. You must run the `do.sh` script you just downloaded. You must run the script as the `root` user with the `USER` environment variable set to your own CLS account userid. (Do not use *abcd0001*; use your own.) Failure to set the `USER=` variable as shown below will cause your account to be locked out of the CLS. Use `su` to run the `do.sh` script: $ echo "$USER" ; pwd abcd0001 # your userid, not abcd0001 /home/abcd0001/CST8207-14W/Assignments/assignment13 # your userid, not abcd0001 $ su -c "USER=$USER sh do.sh" # must be double quotes, not single This `do.sh` script runs a **Fetch** program that will connect from your CentOS machine to the CLS using your account name in the `USER` variable. It will copy selected files from your CentOS machine to your `assignment13` directory on the CLS. It will then run the checking program on the CLS to check your work. You will need to answer one question about your IP address, and then wait and type in your CLS password, as shown below: --------------------------------------------------------------------------- abcd0001: FETCH version 3. Connecting to CLS as USER='abcd0001' using ssh --------------------------------------------------------------------------- abcd0001: Use local Algonquin IP cst8207-alg.idallen.ca [y/N/?]? n abcd0001: Please wait; using ssh to connect to user 'abcd0001' on cst8207.idallen.ca ... *** COURSE LINUX SERVER *** abcd0001@cst8207.idallen.ca's password: # enter your CLS password --------------------------------------------------------------------------- idallen-ubuntu assignment13fetch_server.sh version 9 run by abcd0001. Please wait; collecting info from abcd0001 Virtual Machine --------------------------------------------------------------------------- VM files collected into CST8207-14W/Assignments/assignment13/abcd0001.tar.bz on CLS. Now running checking program for abcd0001 on CLS: [... checking program output appears here ...] ### Notes on the Fetch program - This **Fetch** program copies files and information from your CentOS virtual machine into a `tar` archive in your account under `assignment13` on the CLS and then runs the checking program on the CLS. If you only run the checking program on the CLS, it won’t update the files from your CentOS VM and it will just check the existing files saved under `assignment13` on the CLS. - The checking program is running on the CLS, not on your CentOS VM. At the start, the checking program will issue messages relevant to your account on the CLS (e.g.&nbsp;errors in your CLS `.bashrc` file or world-writable files on the CLS). These errors are on the CLS, not on your CentOS machine. Part II - Check and Submit -------------------------- When you are done with your assignment, you need to run the checking program one last time on the CLS (not from CentOS) and submit the output file, as follows: Do all this on the [Course Linux Server] when you are ready to submit: 1. There is a [Checking Program] named `assignment13check` in the [Source Directory] on the CLS. Create a [Symbolic Link] to this program named `check` under your new `assignment13` directory on the CLS so that you can easily run the program to check your work and assign your work a mark on the CLS. Note: You can create a symbolic link to this executable program but you do not have permission to read or copy the program file. 2. Execute the above “check” program on the CLS using its symbolic link. (Review the [Search Path] notes if you forget how to run a program by pathname from the command line.) This program will check your fetched CentOS work, assign you a mark, and display the output on your screen. (You may want to paginate the long output so you can read all of it.) Remember: The checking program does not fetch new files to the CLS from your CentOS VM. You must run the **Fetch** program on your CentOS VM to update the fetched files on the CLS so that the checking program can mark them on the CLS. You may run the “check” program as many times as you wish, to correct mistakes and get the best mark. **Some task sections require you to finish the whole section before running the checking program at the end; you may not always be able to run the checking program successfully after every single task step.** 3. When you are done with checking this assignment, and you like what you see on your screen, **redirect** the output of the [Checking Program] into the text file `assignment13.txt` under your `assignment13` directory on the CLS. Use the *exact* name `assignment13.txt` in your `assignment13` directory. Case (upper/lower case letters) matters. Be absolutely accurate, as if your marks depended on it. Do not edit the file. - Make sure the file actually contains the output of the checking program! - The last text line of the file should begin with: `YOUR MARK for` - Really! **MAKE SURE THE FILE HAS YOUR MARKS IN IT!** 4. Transfer the above `assignment13.txt` file from the CLS to your local computer and verify that the file still contains all the output from the checking program. Do not edit this file! No empty files, please! Edited or damaged files will not be marked. You may want to refer to your [File Transfer] notes. - Make sure the file actually contains the output of the checking program! - The last text line of the file should begin with: `YOUR MARK for` - Really! **MAKE SURE THE FILE HAS YOUR MARKS IN IT!** 5. Upload the `assignment13.txt` file under the correct Assignment area on Blackboard (with the exact correct name) before the due date. Upload the file via the **assignment13** “Upload Assignment” facility in Blackboard: click on the underlined **assignment13** link in Blackboard. Use “**Attach File**” and “**Submit**” to upload your plain text file. No word-processor documents. Do not send email. Use only “Attach File”. Do not enter any text into the **Submission** or **Comments** boxes on Blackboard; I do not read them. Use only the “**Attach File**” section followed by the **Submit** button. If you need to comment on any assignment submission, send me [email]. You can upload the file more than once; I only look at the most recent. You must upload the file with the correct name; you cannot correct the name as you upload it to Blackboard. 6. **Verify that Blackboard has received your submission**: After using the *Submit* button, you will see a page titled *Review Submission History* that will show all your submissions. a) Verify that your latest submission has the correct 16-character, lower-case file name beside the *Attached Files* heading. b) The *Submission Field* and *Student Comments* headings must be **empty**. (I do not read them.) c) **Save a screen capture** showing the uploaded file name. If there is an upload missing, you will need this to prove that you uploaded the file. (Blackboard has never lost a file.) You will also see the *Review Submission History* page any time you already have an assignment attempt uploaded and you click on the underlined **assignment13** link. You cannot delete an assignment attempt, but you can always upload a new version. I only mark the latest version. 7. Your instructor may also mark files in your directory in your CLS account after the due date. Leave everything there on the CLS. **Do not delete any assignment work from the CLS until after the term is over!** - I do not accept any assignment submissions by email. Use only the Blackboard *Attach File*. No word processor documents. Plain Text only. - Use the *exact* file name given above. Upload only one single file of Linux-format plain text, not HTML, not RTF, not MSWord. No fonts, no word-processing. Linux plain text only. - **NO EMAIL, WORD PROCESSOR, PDF, RTF, or HTML DOCUMENTS ACCEPTED.** - No marks are awarded for submitting under the wrong assignment number or for using the wrong file name. Use the exact 16-character, lower-case name given above. - WARNING: Some inattentive students don’t read all these words. Don’t make that mistake! Be exact. **READ ALL THE WORDS. OH PLEASE, PLEASE, PLEASE READ ALL THE WORDS!** -- | Ian! D. Allen - idallen@idallen.ca - Ottawa, Ontario, Canada | Home Page: http://idallen.com/ Contact Improv: http://contactimprov.ca/ | College professor (Free/Libre GNU+Linux) at: http://teaching.idallen.com/ | Defend digital freedom: http://eff.org/ and have fun: http://fools.ca/ [Plain Text] - plain text version of this page in [Pandoc Markdown] format [www.idallen.com]: http://www.idallen.com/ [hyperlink URLs]: indexcgi.cgi#XImportant_Notes__alphabetical_order_ [Assignments]: indexcgi.cgi#XAssignments [CentOS Virtual Machine]: 000_centos_install.html [Checking Program]: #checking-marking-and-submitting-your-work [Course Linux Server]: 070_course_linux_server.html [Partitions and File Systems]: 720_partitions_and_file_systems.html [Booting and GRUB]: 750_booting_and_grub.html [CST8207 GNU/Linux Operating Systems I]: ../ [Partitioning with fdisk]: http://tldp.org/HOWTO/Partition/fdisk_partitioning.html [Network Diagnostics]: 000_network_diagnostics.html [The Answer File]: #the-answer-file-answer.txt [Remote Login]: 110_remote_login.html [Part II - Check and Submit]: #part-ii---check-and-submit [Create VMware Disk]: 730_create_vmware_disk.pdf [**Hint**]: 190_glob_patterns.html [MebiBytes]: https://en.wikipedia.org/wiki/Mebibyte [Links and Inodes]: 455_links_and_inodes.html#many-file-systems---one-root [Why?]: http://unix.stackexchange.com/questions/7950/reserved-space-for-root-on-a-filesystem-why [CentOS 6 GRUB Menu]: data/centos6_grub_menu.jpg "CentOS 6 GRUB Menu" [CentOS 6 Kernel Options]: data/centos6_kernel.png "CentOS 6 Kernel Options" [Source Directory]: #the-cls-source-directory [Symbolic Link]: 460_symbolic_links.html [Search Path]: 400_search_path.html [File Transfer]: 015_file_transfer.html [email]: mailto:idallen@idallen.ca [Plain Text]: assignment13.txt [Pandoc Markdown]: http://johnmacfarlane.net/pandoc/ 
    </http:>
   </http:>
  </idallen@idallen.ca>
 </body>
</html>